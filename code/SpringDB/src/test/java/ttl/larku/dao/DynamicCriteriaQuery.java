package ttl.larku.dao;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.annotation.DirtiesContext.ClassMode;
import org.springframework.test.context.jdbc.Sql;
import ttl.larku.domain.Student;
import ttl.larku.domain.Student_;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.EntityType;
import javax.persistence.metamodel.ManagedType;
import javax.persistence.metamodel.Metamodel;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import static java.lang.System.out;
import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
//@Sql(scripts = {"/schema-h2.sql", "/data-h2.sql"}, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@Sql(scripts = { "/ttl/larku/db/createVersionedDB-h2.sql",
		"/ttl/larku/db/populateVersionedDB-h2.sql" }, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@DirtiesContext(classMode = ClassMode.AFTER_CLASS)
public class DynamicCriteriaQuery {

	@Autowired
	private EntityManager em;

	@Test
	public void testBuildDynamicWithStrings() {
		Student example = new Student();
		example.setStatus(Student.Status.FULL_TIME);
		buildDynamicQueryWithStringsAndQueryParams(example);
	}


	public void buildDynamicQueryWithStringsAndQueryParams(Student example) {
		StringBuilder builder = new StringBuilder().append("select distinct s from Student s "
				+ "left join fetch s.classes sc left join fetch sc.course where ");
		if(example.getStatus() != null) {
			builder.append(" s.status = '" + example.getStatus() + "'");
		}else if(example.getName() != null) {
			builder.append(" s.name like %" + example.getName() + "%");
		}

		String queryString = builder.toString();

		out.println("queryString is " + queryString);

		TypedQuery<Student> query = em.createQuery(queryString, Student.class);
//		query.setParameter("status", Student.Status.FULL_TIME);
		List<Student> tqStudents = query.getResultList();
		out.println("TQStudents: ");
		tqStudents.forEach(System.out::println);
		assertEquals(2, tqStudents.size());

	}

	@Test
	public void testDynamicCriteria() {
		Student example = new Student();
		example.setStatus(Student.Status.FULL_TIME);
		example.setName("Ana");
//		testDynamicCriteriaQuery(example);
		testDynamicCriteriaQueryUsingMetaModel(example);
	}

	public void testDynamicCriteriaQuery(Student example) {
		//Get the builder
		CriteriaBuilder builder = em.getCriteriaBuilder();
		//Create a query that will return Students
		CriteriaQuery<Student> cq = builder.createQuery(Student.class);

		//Student is also going to be the (only) root entity we will
		//be searching from.  This need not always be the same as the
		//type returned from the query.  This is the 'From' clause.
		Root<Student> queryRoot = cq.from(Student.class);
		queryRoot.fetch("classes", JoinType.LEFT); //.fetch("course", JoinType.LEFT);

		//We are going to be selecting Students.
		cq.select(queryRoot).distinct(true);

		//Build up a List of javax.persistence.criteria.Predicate objects,
		//based on what is not null in the example Student.
		List<javax.persistence.criteria.Predicate> preds = new ArrayList<>();
		if(example.getStatus() != null) {
			preds.add(builder.equal(queryRoot.get("status"), example.getStatus()));
		}
		if(example.getName() != null) {
			preds.add(builder.like(queryRoot.get("name"), "%" + example.getName() + "%"));
		}

		//Now 'or' them together.
		Predicate finalPred = builder.or(preds.toArray(new javax.persistence.criteria.Predicate[0]));

		//And set them as the where clause of our query.
		cq.where(finalPred);

		List<Student> students = em.createQuery(cq).getResultList();

		out.println("Students: ");
		students.forEach(System.out::println);
		assertEquals(3, students.size());

	}

	/**
	 * Here we are going to use the MetaModel.
	 * 1) MetaModel is generated by Hibernate generator.  Look in
	 *    pom.xml file for plugin and generated location.
	 * 2) Instead of hard coded property names, we are referring to
	 *    the properties using the MetaModel.
	 *    e.g. Student_.name instead of "name"
	 *    e.g. Student_.status instead of "status"
	 *    e.g. Student_.classes instead of "classes"
	 *
	 * @param example
	 */
	public void testDynamicCriteriaQueryUsingMetaModel(Student example) {
		//Get the builder
		CriteriaBuilder builder = em.getCriteriaBuilder();
		//Create a query that will return Students
		CriteriaQuery<Student> cq = builder.createQuery(Student.class);

		//Student is also going to be the (only) root entity we will
		//be searching from.  This need not always be the same as the
		//type returned from the query.  This is the 'From' clause.
		Root<Student> queryRoot = cq.from(Student.class);
		queryRoot.fetch(Student_.classes, JoinType.LEFT); //.fetch("course", JoinType.LEFT);

		//We are going to be selecting Students.
		cq.select(queryRoot).distinct(true);

		//Build up a List of javax.persistence.criteria.Predicate objects,
		//based on what is not null in the example Student.
		List<javax.persistence.criteria.Predicate> preds = new ArrayList<>();
		if(example.getStatus() != null) {
			preds.add(builder.equal(queryRoot.get(Student_.status), example.getStatus()));
		}
		if(example.getName() != null) {
			preds.add(builder.like(queryRoot.get(Student_.name), "%" + example.getName() + "%"));
		}

		//Now 'or' them together.
		Predicate finalPred = builder.or(preds.toArray(new javax.persistence.criteria.Predicate[0]));

		//And set them as the where clause of our query.
		cq.where(finalPred);

		List<Student> students = em.createQuery(cq).getResultList();

		out.println("Students: ");
		students.forEach(System.out::println);
		assertEquals(3, students.size());

	}


	@PersistenceContext
	private EntityManager entityManager;

	@Test
	public void playWithMetaModel() {
		Metamodel metaModel = entityManager.getMetamodel();

		Set<ManagedType<?>> managedTypes = metaModel.getManagedTypes();
		for(ManagedType<?> mt : managedTypes) {
			out.println("ManagedType: " + mt);
		}

		Set<EntityType<?>> entityTypes = metaModel.getEntities();
		for(EntityType<?> mt : entityTypes) {
			out.println("EntityType: " + mt);
		}

	}

}
